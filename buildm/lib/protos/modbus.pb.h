// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modbus.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modbus_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modbus_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modbus_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modbus_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modbus_2eproto;
class ModbusConfig;
class ModbusConfigDefaultTypeInternal;
extern ModbusConfigDefaultTypeInternal _ModbusConfig_default_instance_;
class ModbusConfigResponse;
class ModbusConfigResponseDefaultTypeInternal;
extern ModbusConfigResponseDefaultTypeInternal _ModbusConfigResponse_default_instance_;
class ModbusConfig_ModbusDevice;
class ModbusConfig_ModbusDeviceDefaultTypeInternal;
extern ModbusConfig_ModbusDeviceDefaultTypeInternal _ModbusConfig_ModbusDevice_default_instance_;
class ModbusConfig_ModbusDevice_ModbusRTUSlaves;
class ModbusConfig_ModbusDevice_ModbusRTUSlavesDefaultTypeInternal;
extern ModbusConfig_ModbusDevice_ModbusRTUSlavesDefaultTypeInternal _ModbusConfig_ModbusDevice_ModbusRTUSlaves_default_instance_;
class ModbusConfig_ModbusDevice_ModbusTCPSlaves;
class ModbusConfig_ModbusDevice_ModbusTCPSlavesDefaultTypeInternal;
extern ModbusConfig_ModbusDevice_ModbusTCPSlavesDefaultTypeInternal _ModbusConfig_ModbusDevice_ModbusTCPSlaves_default_instance_;
class ModbusConfig_ModbusDevice_ModbusTag;
class ModbusConfig_ModbusDevice_ModbusTagDefaultTypeInternal;
extern ModbusConfig_ModbusDevice_ModbusTagDefaultTypeInternal _ModbusConfig_ModbusDevice_ModbusTag_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ModbusConfig* Arena::CreateMaybeMessage<::ModbusConfig>(Arena*);
template<> ::ModbusConfigResponse* Arena::CreateMaybeMessage<::ModbusConfigResponse>(Arena*);
template<> ::ModbusConfig_ModbusDevice* Arena::CreateMaybeMessage<::ModbusConfig_ModbusDevice>(Arena*);
template<> ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* Arena::CreateMaybeMessage<::ModbusConfig_ModbusDevice_ModbusRTUSlaves>(Arena*);
template<> ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* Arena::CreateMaybeMessage<::ModbusConfig_ModbusDevice_ModbusTCPSlaves>(Arena*);
template<> ::ModbusConfig_ModbusDevice_ModbusTag* Arena::CreateMaybeMessage<::ModbusConfig_ModbusDevice_ModbusTag>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum Parity : int {
  ODD = 0,
  EVEN = 1,
  NONE = 2,
  Parity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Parity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Parity_IsValid(int value);
constexpr Parity Parity_MIN = ODD;
constexpr Parity Parity_MAX = NONE;
constexpr int Parity_ARRAYSIZE = Parity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Parity_descriptor();
template<typename T>
inline const std::string& Parity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Parity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Parity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Parity_descriptor(), enum_t_value);
}
inline bool Parity_Parse(
    const std::string& name, Parity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Parity>(
    Parity_descriptor(), name, value);
}
enum BaudRate : int {
  BAUD110 = 0,
  BAUD300 = 1,
  BAUD600 = 2,
  BAUD1200 = 3,
  BAUD2400 = 4,
  BAUD4800 = 5,
  BAUD9600 = 6,
  BAUD14400 = 7,
  BAUD19200 = 8,
  BAUD38400 = 9,
  BAUD56000 = 10,
  BAUD57600 = 11,
  BAUD115200 = 12,
  BAUD125000 = 13,
  BAUD256000 = 14,
  BaudRate_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BaudRate_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BaudRate_IsValid(int value);
constexpr BaudRate BaudRate_MIN = BAUD110;
constexpr BaudRate BaudRate_MAX = BAUD256000;
constexpr int BaudRate_ARRAYSIZE = BaudRate_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BaudRate_descriptor();
template<typename T>
inline const std::string& BaudRate_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BaudRate>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BaudRate_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BaudRate_descriptor(), enum_t_value);
}
inline bool BaudRate_Parse(
    const std::string& name, BaudRate* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BaudRate>(
    BaudRate_descriptor(), name, value);
}
enum FunctionCode : int {
  RRAD_COIL = 0,
  READ_DISCRETE_INPUTS = 1,
  READ_MULTIPLE_HOLDING_REGISTERS = 2,
  READ_INPUT_REGISTERS = 3,
  WRITE_SINGLE_COIL = 4,
  WRITE_SINGLE_HOLDING_REGISTER = 5,
  WRITE_MULTIPLE_COILS = 6,
  WRITE_MULTIPLE_HLDING_REGISTERS = 7,
  FunctionCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FunctionCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FunctionCode_IsValid(int value);
constexpr FunctionCode FunctionCode_MIN = RRAD_COIL;
constexpr FunctionCode FunctionCode_MAX = WRITE_MULTIPLE_HLDING_REGISTERS;
constexpr int FunctionCode_ARRAYSIZE = FunctionCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FunctionCode_descriptor();
template<typename T>
inline const std::string& FunctionCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FunctionCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FunctionCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FunctionCode_descriptor(), enum_t_value);
}
inline bool FunctionCode_Parse(
    const std::string& name, FunctionCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FunctionCode>(
    FunctionCode_descriptor(), name, value);
}
enum ModbusDataType : int {
  MBOOLEAN = 0,
  MINT8 = 1,
  MUINT8 = 2,
  MINT16 = 3,
  MUINT16 = 4,
  MINT32 = 5,
  MUINT32 = 6,
  MINT64 = 7,
  MUINT64 = 8,
  MFLOAT32 = 9,
  MFLOAT64 = 10,
  MSTRING = 11,
  ModbusDataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ModbusDataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ModbusDataType_IsValid(int value);
constexpr ModbusDataType ModbusDataType_MIN = MBOOLEAN;
constexpr ModbusDataType ModbusDataType_MAX = MSTRING;
constexpr int ModbusDataType_ARRAYSIZE = ModbusDataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModbusDataType_descriptor();
template<typename T>
inline const std::string& ModbusDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModbusDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModbusDataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModbusDataType_descriptor(), enum_t_value);
}
inline bool ModbusDataType_Parse(
    const std::string& name, ModbusDataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModbusDataType>(
    ModbusDataType_descriptor(), name, value);
}
// ===================================================================

class ModbusConfigResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ModbusConfigResponse) */ {
 public:
  ModbusConfigResponse();
  virtual ~ModbusConfigResponse();

  ModbusConfigResponse(const ModbusConfigResponse& from);
  ModbusConfigResponse(ModbusConfigResponse&& from) noexcept
    : ModbusConfigResponse() {
    *this = ::std::move(from);
  }

  inline ModbusConfigResponse& operator=(const ModbusConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModbusConfigResponse& operator=(ModbusConfigResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModbusConfigResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModbusConfigResponse* internal_default_instance() {
    return reinterpret_cast<const ModbusConfigResponse*>(
               &_ModbusConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ModbusConfigResponse& a, ModbusConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModbusConfigResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModbusConfigResponse* New() const final {
    return CreateMaybeMessage<ModbusConfigResponse>(nullptr);
  }

  ModbusConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModbusConfigResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModbusConfigResponse& from);
  void MergeFrom(const ModbusConfigResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModbusConfigResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ModbusConfigResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modbus_2eproto);
    return ::descriptor_table_modbus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorDescFieldNumber = 3,
    kSuccessFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
  };
  // string errorDesc = 3;
  void clear_errordesc();
  const std::string& errordesc() const;
  void set_errordesc(const std::string& value);
  void set_errordesc(std::string&& value);
  void set_errordesc(const char* value);
  void set_errordesc(const char* value, size_t size);
  std::string* mutable_errordesc();
  std::string* release_errordesc();
  void set_allocated_errordesc(std::string* errordesc);
  private:
  const std::string& _internal_errordesc() const;
  void _internal_set_errordesc(const std::string& value);
  std::string* _internal_mutable_errordesc();
  public:

  // bool Success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 errorCode = 2;
  void clear_errorcode();
  ::PROTOBUF_NAMESPACE_ID::int32 errorcode() const;
  void set_errorcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_errorcode() const;
  void _internal_set_errorcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ModbusConfigResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errordesc_;
  bool success_;
  ::PROTOBUF_NAMESPACE_ID::int32 errorcode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modbus_2eproto;
};
// -------------------------------------------------------------------

class ModbusConfig_ModbusDevice_ModbusRTUSlaves :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ModbusConfig.ModbusDevice.ModbusRTUSlaves) */ {
 public:
  ModbusConfig_ModbusDevice_ModbusRTUSlaves();
  virtual ~ModbusConfig_ModbusDevice_ModbusRTUSlaves();

  ModbusConfig_ModbusDevice_ModbusRTUSlaves(const ModbusConfig_ModbusDevice_ModbusRTUSlaves& from);
  ModbusConfig_ModbusDevice_ModbusRTUSlaves(ModbusConfig_ModbusDevice_ModbusRTUSlaves&& from) noexcept
    : ModbusConfig_ModbusDevice_ModbusRTUSlaves() {
    *this = ::std::move(from);
  }

  inline ModbusConfig_ModbusDevice_ModbusRTUSlaves& operator=(const ModbusConfig_ModbusDevice_ModbusRTUSlaves& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModbusConfig_ModbusDevice_ModbusRTUSlaves& operator=(ModbusConfig_ModbusDevice_ModbusRTUSlaves&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModbusConfig_ModbusDevice_ModbusRTUSlaves& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModbusConfig_ModbusDevice_ModbusRTUSlaves* internal_default_instance() {
    return reinterpret_cast<const ModbusConfig_ModbusDevice_ModbusRTUSlaves*>(
               &_ModbusConfig_ModbusDevice_ModbusRTUSlaves_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ModbusConfig_ModbusDevice_ModbusRTUSlaves& a, ModbusConfig_ModbusDevice_ModbusRTUSlaves& b) {
    a.Swap(&b);
  }
  inline void Swap(ModbusConfig_ModbusDevice_ModbusRTUSlaves* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModbusConfig_ModbusDevice_ModbusRTUSlaves* New() const final {
    return CreateMaybeMessage<ModbusConfig_ModbusDevice_ModbusRTUSlaves>(nullptr);
  }

  ModbusConfig_ModbusDevice_ModbusRTUSlaves* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModbusConfig_ModbusDevice_ModbusRTUSlaves>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModbusConfig_ModbusDevice_ModbusRTUSlaves& from);
  void MergeFrom(const ModbusConfig_ModbusDevice_ModbusRTUSlaves& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModbusConfig_ModbusDevice_ModbusRTUSlaves* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ModbusConfig.ModbusDevice.ModbusRTUSlaves";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modbus_2eproto);
    return ::descriptor_table_modbus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 1,
    kClientIDFieldNumber = 2,
    kBaudRateFieldNumber = 3,
    kParityFieldNumber = 4,
    kStartBitFieldNumber = 5,
    kStopBitFieldNumber = 6,
    kDataBitFieldNumber = 7,
  };
  // string clientName = 1;
  void clear_clientname();
  const std::string& clientname() const;
  void set_clientname(const std::string& value);
  void set_clientname(std::string&& value);
  void set_clientname(const char* value);
  void set_clientname(const char* value, size_t size);
  std::string* mutable_clientname();
  std::string* release_clientname();
  void set_allocated_clientname(std::string* clientname);
  private:
  const std::string& _internal_clientname() const;
  void _internal_set_clientname(const std::string& value);
  std::string* _internal_mutable_clientname();
  public:

  // string clientID = 2;
  void clear_clientid();
  const std::string& clientid() const;
  void set_clientid(const std::string& value);
  void set_clientid(std::string&& value);
  void set_clientid(const char* value);
  void set_clientid(const char* value, size_t size);
  std::string* mutable_clientid();
  std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // .BaudRate baudRate = 3;
  void clear_baudrate();
  ::BaudRate baudrate() const;
  void set_baudrate(::BaudRate value);
  private:
  ::BaudRate _internal_baudrate() const;
  void _internal_set_baudrate(::BaudRate value);
  public:

  // .Parity parity = 4;
  void clear_parity();
  ::Parity parity() const;
  void set_parity(::Parity value);
  private:
  ::Parity _internal_parity() const;
  void _internal_set_parity(::Parity value);
  public:

  // int32 startBit = 5;
  void clear_startbit();
  ::PROTOBUF_NAMESPACE_ID::int32 startbit() const;
  void set_startbit(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_startbit() const;
  void _internal_set_startbit(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 stopBit = 6;
  void clear_stopbit();
  ::PROTOBUF_NAMESPACE_ID::int32 stopbit() const;
  void set_stopbit(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_stopbit() const;
  void _internal_set_stopbit(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 dataBit = 7;
  void clear_databit();
  ::PROTOBUF_NAMESPACE_ID::int32 databit() const;
  void set_databit(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_databit() const;
  void _internal_set_databit(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ModbusConfig.ModbusDevice.ModbusRTUSlaves)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
  int baudrate_;
  int parity_;
  ::PROTOBUF_NAMESPACE_ID::int32 startbit_;
  ::PROTOBUF_NAMESPACE_ID::int32 stopbit_;
  ::PROTOBUF_NAMESPACE_ID::int32 databit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modbus_2eproto;
};
// -------------------------------------------------------------------

class ModbusConfig_ModbusDevice_ModbusTCPSlaves :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ModbusConfig.ModbusDevice.ModbusTCPSlaves) */ {
 public:
  ModbusConfig_ModbusDevice_ModbusTCPSlaves();
  virtual ~ModbusConfig_ModbusDevice_ModbusTCPSlaves();

  ModbusConfig_ModbusDevice_ModbusTCPSlaves(const ModbusConfig_ModbusDevice_ModbusTCPSlaves& from);
  ModbusConfig_ModbusDevice_ModbusTCPSlaves(ModbusConfig_ModbusDevice_ModbusTCPSlaves&& from) noexcept
    : ModbusConfig_ModbusDevice_ModbusTCPSlaves() {
    *this = ::std::move(from);
  }

  inline ModbusConfig_ModbusDevice_ModbusTCPSlaves& operator=(const ModbusConfig_ModbusDevice_ModbusTCPSlaves& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModbusConfig_ModbusDevice_ModbusTCPSlaves& operator=(ModbusConfig_ModbusDevice_ModbusTCPSlaves&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModbusConfig_ModbusDevice_ModbusTCPSlaves& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModbusConfig_ModbusDevice_ModbusTCPSlaves* internal_default_instance() {
    return reinterpret_cast<const ModbusConfig_ModbusDevice_ModbusTCPSlaves*>(
               &_ModbusConfig_ModbusDevice_ModbusTCPSlaves_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ModbusConfig_ModbusDevice_ModbusTCPSlaves& a, ModbusConfig_ModbusDevice_ModbusTCPSlaves& b) {
    a.Swap(&b);
  }
  inline void Swap(ModbusConfig_ModbusDevice_ModbusTCPSlaves* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModbusConfig_ModbusDevice_ModbusTCPSlaves* New() const final {
    return CreateMaybeMessage<ModbusConfig_ModbusDevice_ModbusTCPSlaves>(nullptr);
  }

  ModbusConfig_ModbusDevice_ModbusTCPSlaves* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModbusConfig_ModbusDevice_ModbusTCPSlaves>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModbusConfig_ModbusDevice_ModbusTCPSlaves& from);
  void MergeFrom(const ModbusConfig_ModbusDevice_ModbusTCPSlaves& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModbusConfig_ModbusDevice_ModbusTCPSlaves* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ModbusConfig.ModbusDevice.ModbusTCPSlaves";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modbus_2eproto);
    return ::descriptor_table_modbus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 1,
    kClientIDFieldNumber = 2,
    kIPFieldNumber = 3,
    kPortFieldNumber = 4,
  };
  // string clientName = 1;
  void clear_clientname();
  const std::string& clientname() const;
  void set_clientname(const std::string& value);
  void set_clientname(std::string&& value);
  void set_clientname(const char* value);
  void set_clientname(const char* value, size_t size);
  std::string* mutable_clientname();
  std::string* release_clientname();
  void set_allocated_clientname(std::string* clientname);
  private:
  const std::string& _internal_clientname() const;
  void _internal_set_clientname(const std::string& value);
  std::string* _internal_mutable_clientname();
  public:

  // string clientID = 2;
  void clear_clientid();
  const std::string& clientid() const;
  void set_clientid(const std::string& value);
  void set_clientid(std::string&& value);
  void set_clientid(const char* value);
  void set_clientid(const char* value, size_t size);
  std::string* mutable_clientid();
  std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // string IP = 3;
  void clear_ip();
  const std::string& ip() const;
  void set_ip(const std::string& value);
  void set_ip(std::string&& value);
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  std::string* mutable_ip();
  std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // int32 port = 4;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ModbusConfig.ModbusDevice.ModbusTCPSlaves)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modbus_2eproto;
};
// -------------------------------------------------------------------

class ModbusConfig_ModbusDevice_ModbusTag :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ModbusConfig.ModbusDevice.ModbusTag) */ {
 public:
  ModbusConfig_ModbusDevice_ModbusTag();
  virtual ~ModbusConfig_ModbusDevice_ModbusTag();

  ModbusConfig_ModbusDevice_ModbusTag(const ModbusConfig_ModbusDevice_ModbusTag& from);
  ModbusConfig_ModbusDevice_ModbusTag(ModbusConfig_ModbusDevice_ModbusTag&& from) noexcept
    : ModbusConfig_ModbusDevice_ModbusTag() {
    *this = ::std::move(from);
  }

  inline ModbusConfig_ModbusDevice_ModbusTag& operator=(const ModbusConfig_ModbusDevice_ModbusTag& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModbusConfig_ModbusDevice_ModbusTag& operator=(ModbusConfig_ModbusDevice_ModbusTag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModbusConfig_ModbusDevice_ModbusTag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModbusConfig_ModbusDevice_ModbusTag* internal_default_instance() {
    return reinterpret_cast<const ModbusConfig_ModbusDevice_ModbusTag*>(
               &_ModbusConfig_ModbusDevice_ModbusTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ModbusConfig_ModbusDevice_ModbusTag& a, ModbusConfig_ModbusDevice_ModbusTag& b) {
    a.Swap(&b);
  }
  inline void Swap(ModbusConfig_ModbusDevice_ModbusTag* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModbusConfig_ModbusDevice_ModbusTag* New() const final {
    return CreateMaybeMessage<ModbusConfig_ModbusDevice_ModbusTag>(nullptr);
  }

  ModbusConfig_ModbusDevice_ModbusTag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModbusConfig_ModbusDevice_ModbusTag>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModbusConfig_ModbusDevice_ModbusTag& from);
  void MergeFrom(const ModbusConfig_ModbusDevice_ModbusTag& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModbusConfig_ModbusDevice_ModbusTag* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ModbusConfig.ModbusDevice.ModbusTag";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modbus_2eproto);
    return ::descriptor_table_modbus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagNameFieldNumber = 1,
    kTagIdFieldNumber = 2,
    kServerIdFieldNumber = 3,
    kDataTypeFieldNumber = 4,
    kFunctionCodeFieldNumber = 5,
    kIntervalTimeFieldNumber = 6,
    kStartingAddressFieldNumber = 7,
    kNumberOfRegistersFieldNumber = 8,
  };
  // string tagName = 1;
  void clear_tagname();
  const std::string& tagname() const;
  void set_tagname(const std::string& value);
  void set_tagname(std::string&& value);
  void set_tagname(const char* value);
  void set_tagname(const char* value, size_t size);
  std::string* mutable_tagname();
  std::string* release_tagname();
  void set_allocated_tagname(std::string* tagname);
  private:
  const std::string& _internal_tagname() const;
  void _internal_set_tagname(const std::string& value);
  std::string* _internal_mutable_tagname();
  public:

  // string tagId = 2;
  void clear_tagid();
  const std::string& tagid() const;
  void set_tagid(const std::string& value);
  void set_tagid(std::string&& value);
  void set_tagid(const char* value);
  void set_tagid(const char* value, size_t size);
  std::string* mutable_tagid();
  std::string* release_tagid();
  void set_allocated_tagid(std::string* tagid);
  private:
  const std::string& _internal_tagid() const;
  void _internal_set_tagid(const std::string& value);
  std::string* _internal_mutable_tagid();
  public:

  // string serverId = 3;
  void clear_serverid();
  const std::string& serverid() const;
  void set_serverid(const std::string& value);
  void set_serverid(std::string&& value);
  void set_serverid(const char* value);
  void set_serverid(const char* value, size_t size);
  std::string* mutable_serverid();
  std::string* release_serverid();
  void set_allocated_serverid(std::string* serverid);
  private:
  const std::string& _internal_serverid() const;
  void _internal_set_serverid(const std::string& value);
  std::string* _internal_mutable_serverid();
  public:

  // .ModbusDataType dataType = 4;
  void clear_datatype();
  ::ModbusDataType datatype() const;
  void set_datatype(::ModbusDataType value);
  private:
  ::ModbusDataType _internal_datatype() const;
  void _internal_set_datatype(::ModbusDataType value);
  public:

  // .FunctionCode functionCode = 5;
  void clear_functioncode();
  ::FunctionCode functioncode() const;
  void set_functioncode(::FunctionCode value);
  private:
  ::FunctionCode _internal_functioncode() const;
  void _internal_set_functioncode(::FunctionCode value);
  public:

  // int32 intervalTime = 6;
  void clear_intervaltime();
  ::PROTOBUF_NAMESPACE_ID::int32 intervaltime() const;
  void set_intervaltime(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_intervaltime() const;
  void _internal_set_intervaltime(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 startingAddress = 7;
  void clear_startingaddress();
  ::PROTOBUF_NAMESPACE_ID::int32 startingaddress() const;
  void set_startingaddress(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_startingaddress() const;
  void _internal_set_startingaddress(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 numberOfRegisters = 8;
  void clear_numberofregisters();
  ::PROTOBUF_NAMESPACE_ID::int32 numberofregisters() const;
  void set_numberofregisters(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_numberofregisters() const;
  void _internal_set_numberofregisters(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ModbusConfig.ModbusDevice.ModbusTag)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serverid_;
  int datatype_;
  int functioncode_;
  ::PROTOBUF_NAMESPACE_ID::int32 intervaltime_;
  ::PROTOBUF_NAMESPACE_ID::int32 startingaddress_;
  ::PROTOBUF_NAMESPACE_ID::int32 numberofregisters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modbus_2eproto;
};
// -------------------------------------------------------------------

class ModbusConfig_ModbusDevice :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ModbusConfig.ModbusDevice) */ {
 public:
  ModbusConfig_ModbusDevice();
  virtual ~ModbusConfig_ModbusDevice();

  ModbusConfig_ModbusDevice(const ModbusConfig_ModbusDevice& from);
  ModbusConfig_ModbusDevice(ModbusConfig_ModbusDevice&& from) noexcept
    : ModbusConfig_ModbusDevice() {
    *this = ::std::move(from);
  }

  inline ModbusConfig_ModbusDevice& operator=(const ModbusConfig_ModbusDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModbusConfig_ModbusDevice& operator=(ModbusConfig_ModbusDevice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModbusConfig_ModbusDevice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModbusConfig_ModbusDevice* internal_default_instance() {
    return reinterpret_cast<const ModbusConfig_ModbusDevice*>(
               &_ModbusConfig_ModbusDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ModbusConfig_ModbusDevice& a, ModbusConfig_ModbusDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(ModbusConfig_ModbusDevice* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModbusConfig_ModbusDevice* New() const final {
    return CreateMaybeMessage<ModbusConfig_ModbusDevice>(nullptr);
  }

  ModbusConfig_ModbusDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModbusConfig_ModbusDevice>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModbusConfig_ModbusDevice& from);
  void MergeFrom(const ModbusConfig_ModbusDevice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModbusConfig_ModbusDevice* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ModbusConfig.ModbusDevice";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modbus_2eproto);
    return ::descriptor_table_modbus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ModbusConfig_ModbusDevice_ModbusRTUSlaves ModbusRTUSlaves;
  typedef ModbusConfig_ModbusDevice_ModbusTCPSlaves ModbusTCPSlaves;
  typedef ModbusConfig_ModbusDevice_ModbusTag ModbusTag;

  // accessors -------------------------------------------------------

  enum : int {
    kModbusTagFieldNumber = 4,
    kModbusRTUSlavesFieldNumber = 2,
    kModbusTCPSlavesFieldNumber = 3,
    kRtuOrTcpFieldNumber = 1,
  };
  // repeated .ModbusConfig.ModbusDevice.ModbusTag modbusTag = 4;
  int modbustag_size() const;
  private:
  int _internal_modbustag_size() const;
  public:
  void clear_modbustag();
  ::ModbusConfig_ModbusDevice_ModbusTag* mutable_modbustag(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ModbusConfig_ModbusDevice_ModbusTag >*
      mutable_modbustag();
  private:
  const ::ModbusConfig_ModbusDevice_ModbusTag& _internal_modbustag(int index) const;
  ::ModbusConfig_ModbusDevice_ModbusTag* _internal_add_modbustag();
  public:
  const ::ModbusConfig_ModbusDevice_ModbusTag& modbustag(int index) const;
  ::ModbusConfig_ModbusDevice_ModbusTag* add_modbustag();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ModbusConfig_ModbusDevice_ModbusTag >&
      modbustag() const;

  // .ModbusConfig.ModbusDevice.ModbusRTUSlaves modbusRTUSlaves = 2;
  bool has_modbusrtuslaves() const;
  private:
  bool _internal_has_modbusrtuslaves() const;
  public:
  void clear_modbusrtuslaves();
  const ::ModbusConfig_ModbusDevice_ModbusRTUSlaves& modbusrtuslaves() const;
  ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* release_modbusrtuslaves();
  ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* mutable_modbusrtuslaves();
  void set_allocated_modbusrtuslaves(::ModbusConfig_ModbusDevice_ModbusRTUSlaves* modbusrtuslaves);
  private:
  const ::ModbusConfig_ModbusDevice_ModbusRTUSlaves& _internal_modbusrtuslaves() const;
  ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* _internal_mutable_modbusrtuslaves();
  public:

  // .ModbusConfig.ModbusDevice.ModbusTCPSlaves modbusTCPSlaves = 3;
  bool has_modbustcpslaves() const;
  private:
  bool _internal_has_modbustcpslaves() const;
  public:
  void clear_modbustcpslaves();
  const ::ModbusConfig_ModbusDevice_ModbusTCPSlaves& modbustcpslaves() const;
  ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* release_modbustcpslaves();
  ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* mutable_modbustcpslaves();
  void set_allocated_modbustcpslaves(::ModbusConfig_ModbusDevice_ModbusTCPSlaves* modbustcpslaves);
  private:
  const ::ModbusConfig_ModbusDevice_ModbusTCPSlaves& _internal_modbustcpslaves() const;
  ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* _internal_mutable_modbustcpslaves();
  public:

  // bool rtuOrTcp = 1;
  void clear_rtuortcp();
  bool rtuortcp() const;
  void set_rtuortcp(bool value);
  private:
  bool _internal_rtuortcp() const;
  void _internal_set_rtuortcp(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ModbusConfig.ModbusDevice)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ModbusConfig_ModbusDevice_ModbusTag > modbustag_;
  ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* modbusrtuslaves_;
  ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* modbustcpslaves_;
  bool rtuortcp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modbus_2eproto;
};
// -------------------------------------------------------------------

class ModbusConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ModbusConfig) */ {
 public:
  ModbusConfig();
  virtual ~ModbusConfig();

  ModbusConfig(const ModbusConfig& from);
  ModbusConfig(ModbusConfig&& from) noexcept
    : ModbusConfig() {
    *this = ::std::move(from);
  }

  inline ModbusConfig& operator=(const ModbusConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModbusConfig& operator=(ModbusConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModbusConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModbusConfig* internal_default_instance() {
    return reinterpret_cast<const ModbusConfig*>(
               &_ModbusConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ModbusConfig& a, ModbusConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ModbusConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModbusConfig* New() const final {
    return CreateMaybeMessage<ModbusConfig>(nullptr);
  }

  ModbusConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModbusConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModbusConfig& from);
  void MergeFrom(const ModbusConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModbusConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ModbusConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modbus_2eproto);
    return ::descriptor_table_modbus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ModbusConfig_ModbusDevice ModbusDevice;

  // accessors -------------------------------------------------------

  enum : int {
    kModbusDeviceFieldNumber = 1,
  };
  // repeated .ModbusConfig.ModbusDevice modbusDevice = 1;
  int modbusdevice_size() const;
  private:
  int _internal_modbusdevice_size() const;
  public:
  void clear_modbusdevice();
  ::ModbusConfig_ModbusDevice* mutable_modbusdevice(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ModbusConfig_ModbusDevice >*
      mutable_modbusdevice();
  private:
  const ::ModbusConfig_ModbusDevice& _internal_modbusdevice(int index) const;
  ::ModbusConfig_ModbusDevice* _internal_add_modbusdevice();
  public:
  const ::ModbusConfig_ModbusDevice& modbusdevice(int index) const;
  ::ModbusConfig_ModbusDevice* add_modbusdevice();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ModbusConfig_ModbusDevice >&
      modbusdevice() const;

  // @@protoc_insertion_point(class_scope:ModbusConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ModbusConfig_ModbusDevice > modbusdevice_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modbus_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ModbusConfigResponse

// bool Success = 1;
inline void ModbusConfigResponse::clear_success() {
  success_ = false;
}
inline bool ModbusConfigResponse::_internal_success() const {
  return success_;
}
inline bool ModbusConfigResponse::success() const {
  // @@protoc_insertion_point(field_get:ModbusConfigResponse.Success)
  return _internal_success();
}
inline void ModbusConfigResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void ModbusConfigResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:ModbusConfigResponse.Success)
}

// int32 errorCode = 2;
inline void ModbusConfigResponse::clear_errorcode() {
  errorcode_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModbusConfigResponse::_internal_errorcode() const {
  return errorcode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModbusConfigResponse::errorcode() const {
  // @@protoc_insertion_point(field_get:ModbusConfigResponse.errorCode)
  return _internal_errorcode();
}
inline void ModbusConfigResponse::_internal_set_errorcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  errorcode_ = value;
}
inline void ModbusConfigResponse::set_errorcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_errorcode(value);
  // @@protoc_insertion_point(field_set:ModbusConfigResponse.errorCode)
}

// string errorDesc = 3;
inline void ModbusConfigResponse::clear_errordesc() {
  errordesc_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ModbusConfigResponse::errordesc() const {
  // @@protoc_insertion_point(field_get:ModbusConfigResponse.errorDesc)
  return _internal_errordesc();
}
inline void ModbusConfigResponse::set_errordesc(const std::string& value) {
  _internal_set_errordesc(value);
  // @@protoc_insertion_point(field_set:ModbusConfigResponse.errorDesc)
}
inline std::string* ModbusConfigResponse::mutable_errordesc() {
  // @@protoc_insertion_point(field_mutable:ModbusConfigResponse.errorDesc)
  return _internal_mutable_errordesc();
}
inline const std::string& ModbusConfigResponse::_internal_errordesc() const {
  return errordesc_.GetNoArena();
}
inline void ModbusConfigResponse::_internal_set_errordesc(const std::string& value) {
  
  errordesc_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ModbusConfigResponse::set_errordesc(std::string&& value) {
  
  errordesc_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ModbusConfigResponse.errorDesc)
}
inline void ModbusConfigResponse::set_errordesc(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  errordesc_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ModbusConfigResponse.errorDesc)
}
inline void ModbusConfigResponse::set_errordesc(const char* value, size_t size) {
  
  errordesc_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ModbusConfigResponse.errorDesc)
}
inline std::string* ModbusConfigResponse::_internal_mutable_errordesc() {
  
  return errordesc_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ModbusConfigResponse::release_errordesc() {
  // @@protoc_insertion_point(field_release:ModbusConfigResponse.errorDesc)
  
  return errordesc_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ModbusConfigResponse::set_allocated_errordesc(std::string* errordesc) {
  if (errordesc != nullptr) {
    
  } else {
    
  }
  errordesc_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errordesc);
  // @@protoc_insertion_point(field_set_allocated:ModbusConfigResponse.errorDesc)
}

// -------------------------------------------------------------------

// ModbusConfig_ModbusDevice_ModbusRTUSlaves

// string clientName = 1;
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::clear_clientname() {
  clientname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusRTUSlaves::clientname() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientName)
  return _internal_clientname();
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_clientname(const std::string& value) {
  _internal_set_clientname(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientName)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusRTUSlaves::mutable_clientname() {
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientName)
  return _internal_mutable_clientname();
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_clientname() const {
  return clientname_.GetNoArena();
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_set_clientname(const std::string& value) {
  
  clientname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_clientname(std::string&& value) {
  
  clientname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientName)
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_clientname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  clientname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientName)
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_clientname(const char* value, size_t size) {
  
  clientname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientName)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_mutable_clientname() {
  
  return clientname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusRTUSlaves::release_clientname() {
  // @@protoc_insertion_point(field_release:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientName)
  
  return clientname_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_allocated_clientname(std::string* clientname) {
  if (clientname != nullptr) {
    
  } else {
    
  }
  clientname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clientname);
  // @@protoc_insertion_point(field_set_allocated:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientName)
}

// string clientID = 2;
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::clear_clientid() {
  clientid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusRTUSlaves::clientid() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientID)
  return _internal_clientid();
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_clientid(const std::string& value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientID)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusRTUSlaves::mutable_clientid() {
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientID)
  return _internal_mutable_clientid();
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_clientid() const {
  return clientid_.GetNoArena();
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_set_clientid(const std::string& value) {
  
  clientid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_clientid(std::string&& value) {
  
  clientid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientID)
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_clientid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  clientid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientID)
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_clientid(const char* value, size_t size) {
  
  clientid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientID)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_mutable_clientid() {
  
  return clientid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusRTUSlaves::release_clientid() {
  // @@protoc_insertion_point(field_release:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientID)
  
  return clientid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  clientid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clientid);
  // @@protoc_insertion_point(field_set_allocated:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientID)
}

// .BaudRate baudRate = 3;
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::clear_baudrate() {
  baudrate_ = 0;
}
inline ::BaudRate ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_baudrate() const {
  return static_cast< ::BaudRate >(baudrate_);
}
inline ::BaudRate ModbusConfig_ModbusDevice_ModbusRTUSlaves::baudrate() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusRTUSlaves.baudRate)
  return _internal_baudrate();
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_set_baudrate(::BaudRate value) {
  
  baudrate_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_baudrate(::BaudRate value) {
  _internal_set_baudrate(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusRTUSlaves.baudRate)
}

// .Parity parity = 4;
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::clear_parity() {
  parity_ = 0;
}
inline ::Parity ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_parity() const {
  return static_cast< ::Parity >(parity_);
}
inline ::Parity ModbusConfig_ModbusDevice_ModbusRTUSlaves::parity() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusRTUSlaves.parity)
  return _internal_parity();
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_set_parity(::Parity value) {
  
  parity_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_parity(::Parity value) {
  _internal_set_parity(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusRTUSlaves.parity)
}

// int32 startBit = 5;
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::clear_startbit() {
  startbit_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_startbit() const {
  return startbit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModbusConfig_ModbusDevice_ModbusRTUSlaves::startbit() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusRTUSlaves.startBit)
  return _internal_startbit();
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_set_startbit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  startbit_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_startbit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_startbit(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusRTUSlaves.startBit)
}

// int32 stopBit = 6;
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::clear_stopbit() {
  stopbit_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_stopbit() const {
  return stopbit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModbusConfig_ModbusDevice_ModbusRTUSlaves::stopbit() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusRTUSlaves.stopBit)
  return _internal_stopbit();
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_set_stopbit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  stopbit_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_stopbit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_stopbit(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusRTUSlaves.stopBit)
}

// int32 dataBit = 7;
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::clear_databit() {
  databit_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_databit() const {
  return databit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModbusConfig_ModbusDevice_ModbusRTUSlaves::databit() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusRTUSlaves.dataBit)
  return _internal_databit();
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_set_databit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  databit_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_databit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_databit(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusRTUSlaves.dataBit)
}

// -------------------------------------------------------------------

// ModbusConfig_ModbusDevice_ModbusTCPSlaves

// string clientName = 1;
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::clear_clientname() {
  clientname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTCPSlaves::clientname() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientName)
  return _internal_clientname();
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_clientname(const std::string& value) {
  _internal_set_clientname(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientName)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTCPSlaves::mutable_clientname() {
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientName)
  return _internal_mutable_clientname();
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_clientname() const {
  return clientname_.GetNoArena();
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_set_clientname(const std::string& value) {
  
  clientname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_clientname(std::string&& value) {
  
  clientname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientName)
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_clientname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  clientname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientName)
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_clientname(const char* value, size_t size) {
  
  clientname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientName)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_mutable_clientname() {
  
  return clientname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTCPSlaves::release_clientname() {
  // @@protoc_insertion_point(field_release:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientName)
  
  return clientname_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_allocated_clientname(std::string* clientname) {
  if (clientname != nullptr) {
    
  } else {
    
  }
  clientname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clientname);
  // @@protoc_insertion_point(field_set_allocated:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientName)
}

// string clientID = 2;
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::clear_clientid() {
  clientid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTCPSlaves::clientid() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientID)
  return _internal_clientid();
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_clientid(const std::string& value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientID)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTCPSlaves::mutable_clientid() {
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientID)
  return _internal_mutable_clientid();
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_clientid() const {
  return clientid_.GetNoArena();
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_set_clientid(const std::string& value) {
  
  clientid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_clientid(std::string&& value) {
  
  clientid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientID)
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_clientid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  clientid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientID)
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_clientid(const char* value, size_t size) {
  
  clientid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientID)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_mutable_clientid() {
  
  return clientid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTCPSlaves::release_clientid() {
  // @@protoc_insertion_point(field_release:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientID)
  
  return clientid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  clientid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clientid);
  // @@protoc_insertion_point(field_set_allocated:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientID)
}

// string IP = 3;
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::clear_ip() {
  ip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTCPSlaves::ip() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTCPSlaves.IP)
  return _internal_ip();
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_ip(const std::string& value) {
  _internal_set_ip(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTCPSlaves.IP)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTCPSlaves::mutable_ip() {
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.ModbusTCPSlaves.IP)
  return _internal_mutable_ip();
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_ip() const {
  return ip_.GetNoArena();
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_set_ip(const std::string& value) {
  
  ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_ip(std::string&& value) {
  
  ip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ModbusConfig.ModbusDevice.ModbusTCPSlaves.IP)
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ModbusConfig.ModbusDevice.ModbusTCPSlaves.IP)
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ModbusConfig.ModbusDevice.ModbusTCPSlaves.IP)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_mutable_ip() {
  
  return ip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTCPSlaves::release_ip() {
  // @@protoc_insertion_point(field_release:ModbusConfig.ModbusDevice.ModbusTCPSlaves.IP)
  
  return ip_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:ModbusConfig.ModbusDevice.ModbusTCPSlaves.IP)
}

// int32 port = 4;
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::clear_port() {
  port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModbusConfig_ModbusDevice_ModbusTCPSlaves::port() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTCPSlaves.port)
  return _internal_port();
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  port_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTCPSlaves.port)
}

// -------------------------------------------------------------------

// ModbusConfig_ModbusDevice_ModbusTag

// string tagName = 1;
inline void ModbusConfig_ModbusDevice_ModbusTag::clear_tagname() {
  tagname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTag::tagname() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTag.tagName)
  return _internal_tagname();
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_tagname(const std::string& value) {
  _internal_set_tagname(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTag.tagName)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTag::mutable_tagname() {
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.ModbusTag.tagName)
  return _internal_mutable_tagname();
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTag::_internal_tagname() const {
  return tagname_.GetNoArena();
}
inline void ModbusConfig_ModbusDevice_ModbusTag::_internal_set_tagname(const std::string& value) {
  
  tagname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_tagname(std::string&& value) {
  
  tagname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ModbusConfig.ModbusDevice.ModbusTag.tagName)
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_tagname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tagname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ModbusConfig.ModbusDevice.ModbusTag.tagName)
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_tagname(const char* value, size_t size) {
  
  tagname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ModbusConfig.ModbusDevice.ModbusTag.tagName)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTag::_internal_mutable_tagname() {
  
  return tagname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTag::release_tagname() {
  // @@protoc_insertion_point(field_release:ModbusConfig.ModbusDevice.ModbusTag.tagName)
  
  return tagname_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_allocated_tagname(std::string* tagname) {
  if (tagname != nullptr) {
    
  } else {
    
  }
  tagname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tagname);
  // @@protoc_insertion_point(field_set_allocated:ModbusConfig.ModbusDevice.ModbusTag.tagName)
}

// string tagId = 2;
inline void ModbusConfig_ModbusDevice_ModbusTag::clear_tagid() {
  tagid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTag::tagid() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTag.tagId)
  return _internal_tagid();
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_tagid(const std::string& value) {
  _internal_set_tagid(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTag.tagId)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTag::mutable_tagid() {
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.ModbusTag.tagId)
  return _internal_mutable_tagid();
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTag::_internal_tagid() const {
  return tagid_.GetNoArena();
}
inline void ModbusConfig_ModbusDevice_ModbusTag::_internal_set_tagid(const std::string& value) {
  
  tagid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_tagid(std::string&& value) {
  
  tagid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ModbusConfig.ModbusDevice.ModbusTag.tagId)
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_tagid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tagid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ModbusConfig.ModbusDevice.ModbusTag.tagId)
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_tagid(const char* value, size_t size) {
  
  tagid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ModbusConfig.ModbusDevice.ModbusTag.tagId)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTag::_internal_mutable_tagid() {
  
  return tagid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTag::release_tagid() {
  // @@protoc_insertion_point(field_release:ModbusConfig.ModbusDevice.ModbusTag.tagId)
  
  return tagid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_allocated_tagid(std::string* tagid) {
  if (tagid != nullptr) {
    
  } else {
    
  }
  tagid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tagid);
  // @@protoc_insertion_point(field_set_allocated:ModbusConfig.ModbusDevice.ModbusTag.tagId)
}

// string serverId = 3;
inline void ModbusConfig_ModbusDevice_ModbusTag::clear_serverid() {
  serverid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTag::serverid() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTag.serverId)
  return _internal_serverid();
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_serverid(const std::string& value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTag.serverId)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTag::mutable_serverid() {
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.ModbusTag.serverId)
  return _internal_mutable_serverid();
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTag::_internal_serverid() const {
  return serverid_.GetNoArena();
}
inline void ModbusConfig_ModbusDevice_ModbusTag::_internal_set_serverid(const std::string& value) {
  
  serverid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_serverid(std::string&& value) {
  
  serverid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ModbusConfig.ModbusDevice.ModbusTag.serverId)
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_serverid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  serverid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ModbusConfig.ModbusDevice.ModbusTag.serverId)
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_serverid(const char* value, size_t size) {
  
  serverid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ModbusConfig.ModbusDevice.ModbusTag.serverId)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTag::_internal_mutable_serverid() {
  
  return serverid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTag::release_serverid() {
  // @@protoc_insertion_point(field_release:ModbusConfig.ModbusDevice.ModbusTag.serverId)
  
  return serverid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_allocated_serverid(std::string* serverid) {
  if (serverid != nullptr) {
    
  } else {
    
  }
  serverid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serverid);
  // @@protoc_insertion_point(field_set_allocated:ModbusConfig.ModbusDevice.ModbusTag.serverId)
}

// .ModbusDataType dataType = 4;
inline void ModbusConfig_ModbusDevice_ModbusTag::clear_datatype() {
  datatype_ = 0;
}
inline ::ModbusDataType ModbusConfig_ModbusDevice_ModbusTag::_internal_datatype() const {
  return static_cast< ::ModbusDataType >(datatype_);
}
inline ::ModbusDataType ModbusConfig_ModbusDevice_ModbusTag::datatype() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTag.dataType)
  return _internal_datatype();
}
inline void ModbusConfig_ModbusDevice_ModbusTag::_internal_set_datatype(::ModbusDataType value) {
  
  datatype_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_datatype(::ModbusDataType value) {
  _internal_set_datatype(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTag.dataType)
}

// .FunctionCode functionCode = 5;
inline void ModbusConfig_ModbusDevice_ModbusTag::clear_functioncode() {
  functioncode_ = 0;
}
inline ::FunctionCode ModbusConfig_ModbusDevice_ModbusTag::_internal_functioncode() const {
  return static_cast< ::FunctionCode >(functioncode_);
}
inline ::FunctionCode ModbusConfig_ModbusDevice_ModbusTag::functioncode() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTag.functionCode)
  return _internal_functioncode();
}
inline void ModbusConfig_ModbusDevice_ModbusTag::_internal_set_functioncode(::FunctionCode value) {
  
  functioncode_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_functioncode(::FunctionCode value) {
  _internal_set_functioncode(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTag.functionCode)
}

// int32 intervalTime = 6;
inline void ModbusConfig_ModbusDevice_ModbusTag::clear_intervaltime() {
  intervaltime_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModbusConfig_ModbusDevice_ModbusTag::_internal_intervaltime() const {
  return intervaltime_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModbusConfig_ModbusDevice_ModbusTag::intervaltime() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTag.intervalTime)
  return _internal_intervaltime();
}
inline void ModbusConfig_ModbusDevice_ModbusTag::_internal_set_intervaltime(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  intervaltime_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_intervaltime(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_intervaltime(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTag.intervalTime)
}

// int32 startingAddress = 7;
inline void ModbusConfig_ModbusDevice_ModbusTag::clear_startingaddress() {
  startingaddress_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModbusConfig_ModbusDevice_ModbusTag::_internal_startingaddress() const {
  return startingaddress_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModbusConfig_ModbusDevice_ModbusTag::startingaddress() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTag.startingAddress)
  return _internal_startingaddress();
}
inline void ModbusConfig_ModbusDevice_ModbusTag::_internal_set_startingaddress(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  startingaddress_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_startingaddress(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_startingaddress(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTag.startingAddress)
}

// int32 numberOfRegisters = 8;
inline void ModbusConfig_ModbusDevice_ModbusTag::clear_numberofregisters() {
  numberofregisters_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModbusConfig_ModbusDevice_ModbusTag::_internal_numberofregisters() const {
  return numberofregisters_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModbusConfig_ModbusDevice_ModbusTag::numberofregisters() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTag.numberOfRegisters)
  return _internal_numberofregisters();
}
inline void ModbusConfig_ModbusDevice_ModbusTag::_internal_set_numberofregisters(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  numberofregisters_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_numberofregisters(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_numberofregisters(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTag.numberOfRegisters)
}

// -------------------------------------------------------------------

// ModbusConfig_ModbusDevice

// bool rtuOrTcp = 1;
inline void ModbusConfig_ModbusDevice::clear_rtuortcp() {
  rtuortcp_ = false;
}
inline bool ModbusConfig_ModbusDevice::_internal_rtuortcp() const {
  return rtuortcp_;
}
inline bool ModbusConfig_ModbusDevice::rtuortcp() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.rtuOrTcp)
  return _internal_rtuortcp();
}
inline void ModbusConfig_ModbusDevice::_internal_set_rtuortcp(bool value) {
  
  rtuortcp_ = value;
}
inline void ModbusConfig_ModbusDevice::set_rtuortcp(bool value) {
  _internal_set_rtuortcp(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.rtuOrTcp)
}

// .ModbusConfig.ModbusDevice.ModbusRTUSlaves modbusRTUSlaves = 2;
inline bool ModbusConfig_ModbusDevice::_internal_has_modbusrtuslaves() const {
  return this != internal_default_instance() && modbusrtuslaves_ != nullptr;
}
inline bool ModbusConfig_ModbusDevice::has_modbusrtuslaves() const {
  return _internal_has_modbusrtuslaves();
}
inline void ModbusConfig_ModbusDevice::clear_modbusrtuslaves() {
  if (GetArenaNoVirtual() == nullptr && modbusrtuslaves_ != nullptr) {
    delete modbusrtuslaves_;
  }
  modbusrtuslaves_ = nullptr;
}
inline const ::ModbusConfig_ModbusDevice_ModbusRTUSlaves& ModbusConfig_ModbusDevice::_internal_modbusrtuslaves() const {
  const ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* p = modbusrtuslaves_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ModbusConfig_ModbusDevice_ModbusRTUSlaves*>(
      &::_ModbusConfig_ModbusDevice_ModbusRTUSlaves_default_instance_);
}
inline const ::ModbusConfig_ModbusDevice_ModbusRTUSlaves& ModbusConfig_ModbusDevice::modbusrtuslaves() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.modbusRTUSlaves)
  return _internal_modbusrtuslaves();
}
inline ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* ModbusConfig_ModbusDevice::release_modbusrtuslaves() {
  // @@protoc_insertion_point(field_release:ModbusConfig.ModbusDevice.modbusRTUSlaves)
  
  ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* temp = modbusrtuslaves_;
  modbusrtuslaves_ = nullptr;
  return temp;
}
inline ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* ModbusConfig_ModbusDevice::_internal_mutable_modbusrtuslaves() {
  
  if (modbusrtuslaves_ == nullptr) {
    auto* p = CreateMaybeMessage<::ModbusConfig_ModbusDevice_ModbusRTUSlaves>(GetArenaNoVirtual());
    modbusrtuslaves_ = p;
  }
  return modbusrtuslaves_;
}
inline ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* ModbusConfig_ModbusDevice::mutable_modbusrtuslaves() {
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.modbusRTUSlaves)
  return _internal_mutable_modbusrtuslaves();
}
inline void ModbusConfig_ModbusDevice::set_allocated_modbusrtuslaves(::ModbusConfig_ModbusDevice_ModbusRTUSlaves* modbusrtuslaves) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete modbusrtuslaves_;
  }
  if (modbusrtuslaves) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      modbusrtuslaves = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modbusrtuslaves, submessage_arena);
    }
    
  } else {
    
  }
  modbusrtuslaves_ = modbusrtuslaves;
  // @@protoc_insertion_point(field_set_allocated:ModbusConfig.ModbusDevice.modbusRTUSlaves)
}

// .ModbusConfig.ModbusDevice.ModbusTCPSlaves modbusTCPSlaves = 3;
inline bool ModbusConfig_ModbusDevice::_internal_has_modbustcpslaves() const {
  return this != internal_default_instance() && modbustcpslaves_ != nullptr;
}
inline bool ModbusConfig_ModbusDevice::has_modbustcpslaves() const {
  return _internal_has_modbustcpslaves();
}
inline void ModbusConfig_ModbusDevice::clear_modbustcpslaves() {
  if (GetArenaNoVirtual() == nullptr && modbustcpslaves_ != nullptr) {
    delete modbustcpslaves_;
  }
  modbustcpslaves_ = nullptr;
}
inline const ::ModbusConfig_ModbusDevice_ModbusTCPSlaves& ModbusConfig_ModbusDevice::_internal_modbustcpslaves() const {
  const ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* p = modbustcpslaves_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ModbusConfig_ModbusDevice_ModbusTCPSlaves*>(
      &::_ModbusConfig_ModbusDevice_ModbusTCPSlaves_default_instance_);
}
inline const ::ModbusConfig_ModbusDevice_ModbusTCPSlaves& ModbusConfig_ModbusDevice::modbustcpslaves() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.modbusTCPSlaves)
  return _internal_modbustcpslaves();
}
inline ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* ModbusConfig_ModbusDevice::release_modbustcpslaves() {
  // @@protoc_insertion_point(field_release:ModbusConfig.ModbusDevice.modbusTCPSlaves)
  
  ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* temp = modbustcpslaves_;
  modbustcpslaves_ = nullptr;
  return temp;
}
inline ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* ModbusConfig_ModbusDevice::_internal_mutable_modbustcpslaves() {
  
  if (modbustcpslaves_ == nullptr) {
    auto* p = CreateMaybeMessage<::ModbusConfig_ModbusDevice_ModbusTCPSlaves>(GetArenaNoVirtual());
    modbustcpslaves_ = p;
  }
  return modbustcpslaves_;
}
inline ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* ModbusConfig_ModbusDevice::mutable_modbustcpslaves() {
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.modbusTCPSlaves)
  return _internal_mutable_modbustcpslaves();
}
inline void ModbusConfig_ModbusDevice::set_allocated_modbustcpslaves(::ModbusConfig_ModbusDevice_ModbusTCPSlaves* modbustcpslaves) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete modbustcpslaves_;
  }
  if (modbustcpslaves) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      modbustcpslaves = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modbustcpslaves, submessage_arena);
    }
    
  } else {
    
  }
  modbustcpslaves_ = modbustcpslaves;
  // @@protoc_insertion_point(field_set_allocated:ModbusConfig.ModbusDevice.modbusTCPSlaves)
}

// repeated .ModbusConfig.ModbusDevice.ModbusTag modbusTag = 4;
inline int ModbusConfig_ModbusDevice::_internal_modbustag_size() const {
  return modbustag_.size();
}
inline int ModbusConfig_ModbusDevice::modbustag_size() const {
  return _internal_modbustag_size();
}
inline void ModbusConfig_ModbusDevice::clear_modbustag() {
  modbustag_.Clear();
}
inline ::ModbusConfig_ModbusDevice_ModbusTag* ModbusConfig_ModbusDevice::mutable_modbustag(int index) {
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.modbusTag)
  return modbustag_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ModbusConfig_ModbusDevice_ModbusTag >*
ModbusConfig_ModbusDevice::mutable_modbustag() {
  // @@protoc_insertion_point(field_mutable_list:ModbusConfig.ModbusDevice.modbusTag)
  return &modbustag_;
}
inline const ::ModbusConfig_ModbusDevice_ModbusTag& ModbusConfig_ModbusDevice::_internal_modbustag(int index) const {
  return modbustag_.Get(index);
}
inline const ::ModbusConfig_ModbusDevice_ModbusTag& ModbusConfig_ModbusDevice::modbustag(int index) const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.modbusTag)
  return _internal_modbustag(index);
}
inline ::ModbusConfig_ModbusDevice_ModbusTag* ModbusConfig_ModbusDevice::_internal_add_modbustag() {
  return modbustag_.Add();
}
inline ::ModbusConfig_ModbusDevice_ModbusTag* ModbusConfig_ModbusDevice::add_modbustag() {
  // @@protoc_insertion_point(field_add:ModbusConfig.ModbusDevice.modbusTag)
  return _internal_add_modbustag();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ModbusConfig_ModbusDevice_ModbusTag >&
ModbusConfig_ModbusDevice::modbustag() const {
  // @@protoc_insertion_point(field_list:ModbusConfig.ModbusDevice.modbusTag)
  return modbustag_;
}

// -------------------------------------------------------------------

// ModbusConfig

// repeated .ModbusConfig.ModbusDevice modbusDevice = 1;
inline int ModbusConfig::_internal_modbusdevice_size() const {
  return modbusdevice_.size();
}
inline int ModbusConfig::modbusdevice_size() const {
  return _internal_modbusdevice_size();
}
inline void ModbusConfig::clear_modbusdevice() {
  modbusdevice_.Clear();
}
inline ::ModbusConfig_ModbusDevice* ModbusConfig::mutable_modbusdevice(int index) {
  // @@protoc_insertion_point(field_mutable:ModbusConfig.modbusDevice)
  return modbusdevice_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ModbusConfig_ModbusDevice >*
ModbusConfig::mutable_modbusdevice() {
  // @@protoc_insertion_point(field_mutable_list:ModbusConfig.modbusDevice)
  return &modbusdevice_;
}
inline const ::ModbusConfig_ModbusDevice& ModbusConfig::_internal_modbusdevice(int index) const {
  return modbusdevice_.Get(index);
}
inline const ::ModbusConfig_ModbusDevice& ModbusConfig::modbusdevice(int index) const {
  // @@protoc_insertion_point(field_get:ModbusConfig.modbusDevice)
  return _internal_modbusdevice(index);
}
inline ::ModbusConfig_ModbusDevice* ModbusConfig::_internal_add_modbusdevice() {
  return modbusdevice_.Add();
}
inline ::ModbusConfig_ModbusDevice* ModbusConfig::add_modbusdevice() {
  // @@protoc_insertion_point(field_add:ModbusConfig.modbusDevice)
  return _internal_add_modbusdevice();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ModbusConfig_ModbusDevice >&
ModbusConfig::modbusdevice() const {
  // @@protoc_insertion_point(field_list:ModbusConfig.modbusDevice)
  return modbusdevice_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Parity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Parity>() {
  return ::Parity_descriptor();
}
template <> struct is_proto_enum< ::BaudRate> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BaudRate>() {
  return ::BaudRate_descriptor();
}
template <> struct is_proto_enum< ::FunctionCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FunctionCode>() {
  return ::FunctionCode_descriptor();
}
template <> struct is_proto_enum< ::ModbusDataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ModbusDataType>() {
  return ::ModbusDataType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modbus_2eproto
